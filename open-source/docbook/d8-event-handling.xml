<sect1 id="事件处理">
  <title>事件处理</title>
  <para>
    Montage在浏览器原生事件处理上包装实现了自身的事件处理模块，但是包装对用户如何使用事件是透明的。Montage事件处理提供几个特性，包括让事件处理代码更简单、属性改变监听器和高性能。
  </para>
  <sect2 id="事件委托">
    <title>事件委托</title>
    <para>
      Montage使用事件委托来管理事件处理和分发。使用事件委托不需要在每一个元素上面定义监听，只需要在父元素上绑定一个监听，
      然后所有的子元素都使用它。
      这样的事件处理方式依赖于<ulink url="http://www.w3.org/TR/DOM-Level-3-Events/#event-flow">DOM
      Level 3 Event Specification</ulink>定义的标准事件“流&quot;。
    </para>
    <para>
      事件委托方式有很多好处。比如，因为减少事件监听器的定义，所以性能更高。在Montage应用中只有一个“原生”事件监听器，它负责所有其它事件的接收和分发，可以把它看做是一个主事件监听器。委托也可以让Montage应用可以监听到对象属性值和数组改变事件。
    </para>
  </sect2>
  <sect2 id="创建事件处理">
    <title>创建事件处理</title>
    <para>
      使用标准的<literal>addEventListener()</literal>函数在目标对象上面注册一个事件处理，在Montage事件处理中，目标对象可以是任意的JavaScript对象，而不是像JavaScript事件处理只可以是DOM元素。
    </para>
    <para>
      <literal>target.addEventListener(eventType, listener[, useCapture]);</literal>
    </para>
    <itemizedlist spacing="compact">
      <listitem>
        <para>
          <literal>eventType</literal> 事件名字的字符串。
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>listener</literal>
          事件处理对象（实现Montage事件监听器接口），或者直接就是一个函数
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>useCapture</literal>是一个布尔参数；如果值为<literal>true</literal>，监听器对象的处理函数会被第一个调用，然后监听器对象子组件对应的监听函数被调用。<literal>useCapture</literal>默认值<literal>false</literal>,也就是冒泡方式(<emphasis role="strong">bubble</emphasis>)传递事件,
          如果是<literal>true</literal>就是捕获方式(<emphasis role="strong">capture</emphasis>)。
        </para>
      </listitem>
    </itemizedlist>
    <sect3 id="montage事件监听器接口">
      <title>Montage事件监听器接口</title>
      <para>
        Montage事件监听接口实现<ulink url="http://dev.w3.org/2006/webapi/DOM-Level-3-Events/html/DOM3-Events.html#interface-EventListener">DOM
        Level 3 EventListener
        interface</ulink>标准定义，这个定义被当前全部浏览器支持。第一步在目标对象上设置一个事件监听器对象，当相应的事件被触发后，浏览器会调用监听器对象的<literal>handleEvent()</literal>方法。
      </para>
      <programlisting>
// DOM Level 3 EventListener interface
var listenerObj = {};
listenerObj.handleEvent = function(event) {
     alert(&quot;Got 'mousedown' event.&quot;);
}
var loginBtn = document.querySelector(&quot;#loginBtn&quot;);
loginBtn.addEventListener(&quot;mousedown&quot;, listenerObj);
</programlisting>
      <para>
        Montage增强了这个接口让开发者更容易使用。在Montage中，不是调用监听器对象的<literal>handleEvent()</literal>方法，而是调用事件对象中与当前事件相应的方法。在事件处理方法的传入参数中包括以下三个数据：
      </para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            事件阶段（冒泡或者捕获）
          </para>
        </listitem>
        <listitem>
          <para>
            事件名字
          </para>
        </listitem>
        <listitem>
          <para>
            缺省的，字符串类型标识符，标识目标DOM元素或者Javascript对象。
          </para>
        </listitem>
      </itemizedlist>
      <para>
        下面的伪代码展示事件模块是如何确定调用监听器对象的什么方法：
      </para>
      <programlisting>
methodToInvoke = &quot;&quot;;
identifier = eventTarget.identifier;
if (event.phase == &quot;bubble&quot; ) {
   methodToInvoke = &quot;handle&quot; + 
                     (identifier ? identifier.toCapitalized() : &quot;&quot;) +
                     eventType.toCapitalized();
} else {
   methodtoInvoke = &quot;capture&quot; + 
                    (identifier ? identifier.toCapitalized() : &quot;&quot;) + 
                     eventType.toCapitalized();
}
</programlisting>
      <para>
        理解Montage事件处理最好的方法是通过例子来了解。
      </para>
    </sect3>
  </sect2>
  <sect2 id="例子">
    <title>例子</title>
    <para>
      下面的代码跟上面的例子一样，只是事件处理方法名是<literal>handleMousedown()</literal>而不是<literal>handleEvent()</literal>（Montage事件处理）。当<literal>loginBtn</literal>触发<literal>mousedown</literal>事件之后这个方法会被自动调用，注意只是在事件冒泡阶段。
    </para>
    <programlisting>
// Listening for mousedown event during bubble phase
var listenerObj = {};
listenerObj.handleMousedown = function(event) {
     alert(&quot;Got 'mousedown' event.&quot;);
}
var loginBtn = document.querySelector(&quot;#loginBtn&quot;);
loginBtn.addEventListener(&quot;mousedown&quot;, listenerObj);
</programlisting>
    <para>
      如果想监听事件的捕获阶段，你需要设置<literal>addEventListener()</literal>第三个参数为<literal>true</literal>，然后修改处理函数<literal>handleMousedown()</literal>名为<literal>captureMousedown()</literal>。
    </para>
    <programlisting>
// Listening for capture events on same element 
var listenerObj = {};
listenerObj.captureMousedown = function(event) {
     alert(&quot;Got 'mousedown' event during bubble phase.&quot;);
}
var loginBtn = document.querySelector(&quot;#loginBtn&quot;);
loginBtn.addEventListener(&quot;mousedown&quot;, listenerObj, true); // useCapture = true
</programlisting>
    <para>
      你还可以指定事件目标对象的<literal>identifier</literal>属性，这样只有相应的事件处理函数会被调用。事件处理模块会调用<literal>identifier</literal>首字面大写的函数。
      在下面的例子中，<literal>loginBtn</literal>的<literal>identifier</literal>值为__login__，所以对应的事件处理函数名为<literal>handleLoginMousedown()</literal>。
    </para>
    <programlisting>
// Using identifier strings on target elements
var listenerObj = {};
// Listener for loginBtn
listenerObj.handleLoginMousedown = function(event) {
    console.log(&quot;mousedown on loginBtn&quot;);
}
var loginBtn = document.querySelector(&quot;#loginBtn&quot;);
// Assign string identifier to button
loginBtn.identifier = &quot;login&quot;;
loginBtn.addEventListener(&quot;mousedown&quot;, listenerObj);
</programlisting>
    <sect3 id="事件处理优先级">
      <title>事件处理优先级</title>
      <para>
        事件处理模块会调用更具体的事件处理。比如下面的例子中，定义了两个事件处理函数，一个包含目标的标识符(<literal>handleLoginMousedown()</literal>)，
        而另外一个不包含(<literal>handleMousedown()</literal>)。
        Montage会调用<literal>handleLoginMousedown()</literal>，因为它比另外一个更具体。
      </para>
      <programlisting>
// Event handler precedence
var listenerObj = {};
listenerObj.handleMousedown = function(event) {
     // This won't get called.
     alert(&quot;Got 'mousedown' event.&quot;);
}
listenerObj.handleLoginMousedown = function (event) {
     alert(&quot;Got 'mousedown' event on event.target&quot;); 
}
var loginBtn = document.querySelector(&quot;#loginBtn&quot;);
loginBtn.identifier = &quot;login&quot;;
loginBtn.addEventListener(&quot;mousedown&quot;, listenerObj);
</programlisting>
      <para>
        注意如果<literal>loginBtn</literal>没有定义<literal>identifier</literal>属性，<literal>handleMousedown()</literal>会被调用。
      </para>
      <para>
        当然如果监听器对象里面没有定义具体的事件处理函数，Montage会调用<literal>handleEvent()</literal>方法。这样就提供了一种对“普通”事件的处理机制。
      </para>
      <programlisting>
// Using default handleEvent() handler
var listenerObj = {};
listenerObj.captureClickEvent = function(event) {
     alert(&quot;Got click event&quot;);
}
listenerObj.handleEvent = function(event) {
     alert(&quot;No specific handler for &quot; + event.type);
}
loginBtn.addEventListener(&quot;mousedown&quot;, listenerObj);
loginBtn.addEventListener(&quot;click&quot;, listenerObj, true);
</programlisting>
    </sect3>
  </sect2>
  <sect2 id="在组件模板中定义事件监听器">
    <title>在组件模板中定义事件监听器</title>
    <para>
      在模板中每个对象可以包含一个&quot;listeners&quot;数组指定监听的事件名字和监听器对象，事件是否是捕获方式（可选）。
    </para>
    <para>
      首先在组件JS文件中新建<literal>handleAction()</literal>方法，这个方法的功能是改变触发该事件按钮的标签。
    </para>
    <programlisting>
// controller.js
var Component = require(&quot;montage/ui/component&quot;).Component;

exports.Controller =  Component.specialize({
    handleAction: {
        value: function(event) {
            event.target.value = &quot;Well done&quot;;
        }
    }
})
</programlisting>
    <para>
      接下来在组件模板中定义按钮组件。按钮组件的<literal>listeners</literal>属性包含事件名字(<literal>action</literal>)和用来处理事件的监听器对象。
    </para>
    <programlisting>
&lt;html&gt;
 ...
&lt;script type=&quot;text/montage-serialization&quot;&gt;
{
    &quot;button&quot; : {
        &quot;name&quot;: &quot;Button&quot;,
        &quot;module&quot;: &quot;montage/ui/button.reel&quot;,
        &quot;properties&quot;: {
            &quot;element&quot;: {&quot;#&quot;: &quot;btn&quot;}
        },
        &quot;listeners&quot;: [
            {
                &quot;type&quot;: &quot;action&quot;,
                &quot;listener&quot;: {&quot;@&quot;: &quot;owner&quot;}
            }
        ]
    }
}
&lt;/script&gt;
 ...
&lt;/html&gt;
</programlisting>
    <para>
      你也可以像下面这样指定<literal>identifier</literal>属性：
    </para>
    <programlisting>
{
    &quot;button&quot; : {
        &quot;name&quot;: &quot;Button&quot;,
        &quot;module&quot;: &quot;montage/ui/button.reel&quot;,
        &quot;properties&quot;: {
            &quot;element&quot;: {&quot;#&quot;: &quot;btn&quot;},
            &quot;identifier&quot;: &quot;purchase&quot;
        },
        &quot;listeners&quot;: [
            {
                &quot;type&quot;: &quot;action&quot;,
                &quot;listener&quot;: {&quot;@&quot;: &quot;owner&quot;}
            }
        ]
    }
}
</programlisting>
  </sect2>
</sect1>
